/*
 * 题目：位计数
 * 给定一个非负的整数num，计算所有满足0 <= i <= num的数i的二进制表示中1的个数，把所有的结果作为一个数组返回.
 *
 * 举个例子：给定num = 5，应当返回[0,1,1,2,1,2].
 *由于计算一个数的二进制表示中1的个数的计算量比较小，可以先对前20个数进行二进制表示，同时计算二进制中1的个数
 *
 *    0    0
      1    1
     10    1
     11    2
    100    1
    101    2
    110    2
    111    3
   1000    1
   1001    2
   1010    2
   1011    3
   1100    2
   1101    3
   1110    3
   1111    4
  10000    1
  10001    2
  10010    2
  10011    3
 *通过观察以上表示，容易发现，其实2^i-2^(i + 1)中的数字的二进制中是比0 - 2^i中的数字的二进制在最高位多了一个1，也就是二进制中1的个数多了一个.
 *
 *根据以上分析，就可以先计算前2个数（0 - 2 ^ 1）的结果，然后计算出（2 ^ 1 - 2 ^ 2）的数的结果，以此类推，一直计算下去。时间复杂度: O(n)
 *
 *
 *
 *
 *
 */


#include <iostream>
#include <vector>
using namespace std;


class Solution {
public:
    vector<int> countBits(int num) {

        vector<int>dp(num + 1, 0);
        dp[0] = 0;
        if(num == 0) return dp;
        dp[1] = 1;
        if(num == 1) return dp;

        int j = 2;
        int size = 2;
        while(j <= num) {
            for(int i = 0;i < size && j <= num; i ++, j ++) {
                dp[j] = dp[i] + 1;
            }
            size = j;
        }
        return dp;
    }
};

